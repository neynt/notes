# CS 486: Intro to AI

Professor: Peter van Beek

## 2017 May 02

- What is intelligence?
  - Remembering, reasoning, planning, solving, learning, adapting
  - Understanding other intelligences and beat them
  - Understanding oneself deeply?

- Thinking is symbolic reasoning.
  - Recall Turing machines, lambda calculus
  - Can humans compute functions that are not Turing computable? >> open question, probably not

- Newell-Simon hypothesis/conjecture:
  - A physical symbol system suffices for intelligence.

- Four categories of AI definitions:
  - Systems that (think | act) (like humans | rationally)

- Thinking rationally
  - "Laws of thought" approach: logic and probability as normative theories.
  - "Rational agent" approach: agent does best thing to achieve its goals.

- Lots of AI applications

## 2018 May 07

- Problem solving using search
  - Find a goal state given constraints on the goal.
  - Find a sequence of actions that leads to the goal state.

- Example: n queens on an nxn board; no threats
- Example: crossword puzzles
- Example: sliding puzzles
- Example: river crossing puzzle with 100kg capacity boat, 100kg parent, two 50kg children
- Example: propositional satisfiability (NP complete)
- Example: partition problem (equalize weights) (NP complete)
- Example: travelling saleswoman problem
- Example: set covering (minimum size committee with all skills)

- Formulate problem solving as graph search.
  - Nodes are states.
  - Edges are actions.
  - Solution is a path from initial state to goal state.
  - May have cost on edges.

- For river crossing puzzle:
  - States are assignments of {boat, parent, child1, child2} to {L, R}
    - 16 states
  - Edges are valid river crossings

- For sliding puzzles:
  - States are permutations of {1, ..., 8, empty}
    - 9! states
  - Edges are valid slides

- For n-queens:
  - States are assignments of {Q1, ..., Qn} to row index (assume Qi is in
    column i)
  - Initial state is assignment of Qi to i
  - Edges are swapping two queens

## 2018 May 09

- Skipped in favour of mental health seminar

- General search algorithm is
  - Start with list of start nodes
  - Until it's empty:
    - Pop a node, and if it isn't the goal, push successor states

  - LIFO queue: Breadth first search
  - FIFO queue: Depth-first search
  - Priority queue: Informed search

- TODO

## 2018 May 14

- Constraint satisfaction problem:
  - You have
    - A set of variables { x1, ..., xn }
    - A set of values for each variable dom(x1), ..., dom(xn)
    - A set of constraints { C1, ..., Cm }
  - And want
    - An assignment to variables that satisfies the constraints
      - ... whether or not there is one?
      - ... any one?
      - ... all of them?
      - ... the optimal one, given some cost function?

- Example domains and constraints
  - Reals -- linear constraints: Gaussian elimination, linear programming
  - Integers -- linear constraints: Integer linear programming,
    branch-and-bound
  - Booleans -- propositional statements
  - Here, we will use finite domains with expressive constraint languages

- Constraint languages
  - Arithmetic operators
  - Logical operators
  - Global constraints: over an arbitrary number of variables
  - Table constraints: enumerate satisfied assignments

- Alldifferent
  - A global constraint over a set of variables that is satisfied iff all
    variables are assigned a different value

- Examples
  - Sudoku:
    - 81 variables x1, ..., x81 for each grid square
    - Rows: alldifferent(x1, ..., x9)
    - Columns: alldifferent(x1, x10, ..., x73)
    - Squares: alldifferent(x1, x2, x3, x10, ..., x21)
    - Given values
  - n-queens: Variables are x1, ..., x4; xi is the row of the queen in column i
  - Crosswords: Variables are squares, domain is latin alphabet

- Detail on constraints
  - An assignment is x = a, where a in dom
  - A tuple t over a list of variables {x1, ..., xk} is a list of values (a1, ..., ak)
    - like a set of assignments
  - In a tuple t, t[xi] is the value for variable xi.
  - A constraint C defined over vars(C) specifies the allowed combination of values for the variables in vars(C).
  - vars(C) is the **scope** or **scheme** of the constraint
  - len(vars(C)) is the **arity** of the constraint
    - Unary constraint: 1
    - Binary constraint: 2
    - Non-binary: > 2
  - In a binary CSP, all constraints are binary.

- Intensional vs. extensional
  - Intensional is implicit. Like "x1 != x2 and |x1 - x2| != 1"
  - Extensional is explicit. Like {(1,3), (1,4), (2,4), (3,1), (4,1), (4,2)}.
    - AKA the table constraint.

- Arc consistency
  - Form of local consistency
  - Given a constraint, remove a value from the domain of a variable if it
    cannot be part of a solution according to that constriant.
  - Formally:
    - Let C be a constraint
    - Domain support:
      - Let x in vars(C)
      - Let a in dom(x)
      - x has a domain support in C if there exists t in C such that t[x] = a
        and t[y] in dom(y) for every y in vars(C).
    - C is arc consistent iff for all x in vars(C), every value a in dom(x) has
      a domain support in C.
      - i.e. if it's possible that x = a can solve the CSP.
  - A CSP is arc consistent if every constraint is arc consistent
  - You can make a CSP arc consistent by repeatedly removing unsupported values
    from the domains.

- Arc consistency algorithm
  - ac: Q:(variable * constraint) list -> boolean
    - while Q is not empty:
      - pop (x, C) from Q
      - if revise(x, C):
        - if dom(x) is empty: return false
        - else: add pairs to Q
    - return true
  - revise: x:variable -> C:constraint -> boolean
    - change = false
    - for a:value in dom(x):
      - if there's no domain support for a in C:
        - remove a from dom(x)
        - change = true
    - return change
