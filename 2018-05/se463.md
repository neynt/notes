# SE 463: Software Requirements Specification and Analysis.

Professor: Joanne Atlee

<!-- 2018 May 1 -->

- I also taught PD 10.
- Course previously had a 120-page document on telephony; now it's focused on
  startups and consulting.
- Textbook: Software Requirements, 3ed.
- Other books: Running Lean, 2ed; Applying UML and Patterns, 3ed.
- Grading: 45% project, 5% professionalism, 50% final

- Successes vs. Flops; examples from Airbnb and Facebook
- Most projects fail because they don't meet the needs of their users, not
  because of bad design or code.

- Common problems:
  - Vague requirements
    - Example: our FYDP. Didn't even try to be precise.
  - Ambiguous requirements
    - An unsucessful attempt was made at precision.
  - Changing requirements
  - Insufficient user input
  - Incomplete requirements
  - Infeasible requirements
    - A technical person should be involved with the requirements to vet the
  - Wrong requirements

- Example: WaterlooWorks
  - Lots of complaints about performance, design
  - Whole ton of missing functionality

- Pain of bad requirements
  - Rework: time spent fixing problems rather than adding value
  - Requirements errors account for 70-85% of rework costs.

- Good requirements are very good for your whole project because a single error
  in requirements propagates down and becomes huge baddies in the
  implementation.

- Types of systems
  - Greenfield vs. brownfield: new product vs. enhancement.
  - Customer-driven vs. market-driven: one person vs. population
  - Web/mobile app vs. Enterprise vs. Infra vs. Safety-critical
  - In-house vs. outsourced

<!-- 2018 May 3 -->

- The problem is to know what the problem is

- Webvan: Early internet startup.
  - Goal: Online grocery store with same-day delivery.
  - Time: Late 1990s.
  - Raised $1.2B to capture a piece of the $500B/yr grocery market
  - Planned to open in 26 cities at the same time
  - Began 1999, closed 2001.
  - Failure reasons:
    - Never found out if there was enough demand for online grocery shopping
    - Turns out people like to pick out their own meat, produce, prepared meals
  - Should have tested the idea out in smaller markets

- Lean Canvas
  - Problem
    - (Existing alternatives)
    - Solution
    - Key Metrics
  - Unique Value Proposition
    - (High-level concept)
    - Unfair Advantage
      - Hard to copy things.
      - NOT lower price, or easy to copy features.
    - Channels (paths to customers)
  - Customer Segments
    - (Early Adopters)
  - Cost Structure
  - Revenue Streams

- Airbnb example
  - Problems solved:
    - Unutilized space (for hosts)
    - A place, a cheap place, a local experience (for guests)
    - (Existing alternatives):
      - Hotels
      - Homeaway
    - Solutions:
      - Website, mobile app, and ratings/reviews
    - Metrics:
      - # new guests, repeat guests
      - # new hosts, repeat hosts
      - review scores
  - UVP: Guests experience what it's like to be a local
    - Unfair advantage:
      - Craigslist "integration"
      - Pro photographers
      - Insurance for hosts
    - Channels:
      - Social media
      - Word of mouth
      - Scraped contents of Craigslist
  - Customers: Tourists, students, hosts

- Charge from the start! Hard to switch to paid later on.

<!-- 2018 May 08 -->

- Hypothesis testing
  - You want to test the guesses in your business model.
  - A hypothesis must be testable and falsifiable.
  - Parts of a hypothesis:
    - Dependent variable: the phenomenon of interest.
    - Independent variables: things that affect the dependent variable.
    - Testability: you should be able to find evidence for your hypothesis.
    - Falsifiability: you should be able to find evidence against your
      hypothesis.
  - Examples:
    - "There is another planet in the universe with life on it." (existence
      property)
    - "Students want to view job postings late at night because that is when
      the system has a fast response time."
      - Late at night? > After midnight
      - A fast response time? > 2 sec
      - "Forall" properties: "Most", "Significant Fraction"
  - Uncertainty: When multiple possibilities remain.

- Interviewing users.
  - 1. Welcome.
    - Thank you for taking the time.
    - We are trying to do this.
    - We wanted to see what people think.
    - This is how the interview will work.
    - Our product doesn't exist yet. We are not trying to sell anything.
  - 2. Collect demographics. "I'd like to learn a bit about you"
    - How do you use products like ours?
  - 3. Tell a story.
  - 4. Problem ranking.
  - 5. Explore customer's worldview.
  - 6. Wrapping up.
  - 7. Document results.

<!-- 2018 May 10 -->

- Stakeholder
  - Very broad term; broader than you think
  - Includes the outside world (regulators, consultants, beneficiaries)
  - Negative stakeholder: People interested in failure of your project.
  - Champion stakeholder
    - The owner/client paying for the project to be developed.
    - Also: Ultimate stakeholder
  - Customer
    - Purchaser of software after it is developed.
    - Can be the client, the user, or neither
  - Users
    - Disfavored users: Should not have access for legal, security, safety
      reasons
    - Software agents and bots
  - Domain expert
    - Understand the problem your software is trying to solve
  - Software engineer
    - Technology expert
  - Other stakeholders
    - Inspectors
    - Market researchers
    - Lawyers
    - Industry standards

- Example: Facebook user classes
  - University students
  - Employers
  - Propagandists (Cambridge Analytica)
  - Corporate PR / branding / ads
  - Toddlers (disfavored)
  - Intelligence agencies
  - Terrorists / activists
  - News outlets
  - Non-user class / no account
  - Lurkers
  - Gamers (Farmville)
  - Old people
  - Politicians
  - Buyers and sellers of things
  - Friends

- Personas
  - For when real users are not available
  - Guard against tendency to build for self
  - Guard against the "elastic user": the "accommodate everyone user"
  - Can be made out of data ("data driven persona")

- User requirements
  - Use case: vertical slice of The Work.
  - Time-triggered use case: Activated when time passes.
  - Example: Patient monitoring system.
    - `[<<actor>> Sensors], [<<actor>> Nurse's station], [<<actor>> time]` all
      connected to `[Patient Monitoring System]`

<!-- 2018 May 15 -->

- Actor generalization
  - It's like actor inheritance
- «include»: "sub" use case used within multiple other use cases
  - often overused
- «extend»: "sub" use case that extends or replaces part of an existing use
  case
  - used in "brownfield" projects (highlight new functionality)
- Use-case description: Textual format. Sequence of actions taken by actors and
  systems.
- User stories: Description of what a user wants to be able to do.
- Three Cs of user stories:
  - Card: As a ROLE, I want SOMETHING so that BENEFIT IS ACHIEVED.
  - Conversation: Discussion 
  - Confirmations: Objective criteria for checking whether the implementation
    meets the requirements.

- Changing requirements
  - 1. Requirements baseline
  - 2. Unique value proposition
  - 3. Project scope

<!-- 2018 May 17 -->

## Guest lecture by migod.

- Du vs. Sie in German.
- English is a Germanic language.
- Workflow models
  - A workflow is a sequence of tasks
- Scenario
  - One full execution path through a use case, listing only observable actions

<!-- 2018 May 24 -->

## Guest lecture by shyamsheth.

- Worked at Fixmo; was cool.
- Geoffrey Moore
- Steve Blank: The Startup Owner's Manual

## Stakeholder Analysis: Is not an academic exercise.

- Often, stakeholders were:
  - Too broad/vague
  - Unreachable (govt regulators, companies)
  - Cannot depend solely on proxies

- Potential proxies:
  - Lawyers
  - Inspectors
  - Food safety regulators
  - Alcohol regulators
  - Industry standards

- Must have proxies:
  - Corrupt politicians
  - Trolls

- Interviewees:
  - Don't tell them it's school busywork
  - IRL, want some separation between yourself and interviewee

- You can do this! Treat it like science.
  - Use your technical network, peers
  - Meetup groups
  - Coffee shops and malls
  - Standing in line, waiting for bus
  - Facebook groups, Craigslist
  - Use your student status

<!-- 2018 May 29 -->

## 8. Elicitation

- Artifact-based
  - Learn by studying docs, systems, artifacts before asking for stakeholders'
    time.
- Stakeholder-based
  - Learn problem-specific, stakeholder-specific details
  - Examples: Stakeholder analysis, questionnaires, interviews, observation,
    task demo, ask suppliers, domain workshop, personas
  - Interviews: Useful for learning
  - Apprenticeship: Master v. Apprentice. Disney's Fantasia.
- Model-based
  - Examples: Modelling, analysis patterns, mockups and prototyping, pilot
    experiments
- Creativity-based
  - Examples: Systemic thinking, brainstorming, creativity workshop, constraint
    relaxation
  - Differs from the others in that the requirements come from yourself, rather
    than outside. Violates the motto, "deliver what the customer wants".
  - Give them what they didn't know they wanted.
  - Innovation: Our job is to give the client, on time and on cost, not what
    they want, but what they never dreamed they wanted; and when they get it,
    they recognize it as something that they wanted all the time.
    - The less you know, the easier it is to come up with new things.
    - Ignorance is extremely important in requirements engineering.
    - DM Berry "the importance of ignorance in requirements engineering" --
      most cited paper.
  - Diverge-converge:
    - Preparation (diverge)
    - Incubation (diverge)
    - Illumination (diverge and converge)
    - Verification (converge)
  - Creativity workshops:
    - The synergy is n(n-1)/2. Quadratic.

<!-- 2018 May 31 -->

## 9. Domain Models

- Dan Berry again
- Half of today will not be on the slides.

- UML: Unusual, undefinable modeling language

- Domain model contains:
  - Real-world entities
  - Relationships between them
  - Subject matter for which we're creating a solution
  - Constraints, environmental assumptions

- Domain model
  - Expressed with UML class diagrams
  - Omit details early on.
    - Start with class name
    - Then add attributes, associations, roles
    - Then maybe types, params, initVals
    - NO operations
    - NO language data types, public, private, static, derived

- Example: airline domain model from web
- Example: migod's java code analyzer

- How to tell what is in the domain model, and what is not.
  - (not in the slides)
  - Take the subset of the universe that affects, and that is affected by, the
    system. Focus on that.

- Traffic light example
  - D: Drivers behave legally, cars function correctly
  - S: Spec of traffic light. Guarantees that perpendicular directions do not
    show green at the same time.
  - R: Perpendicular traffic does not collide.

<!-- 2018 Jun 7 -->

## Guest lecture: Robyn Lutz

- Robyn Lutz, Iowa State University

- Requirements engineering for a molecular programmed nanosystem
- TEZE: Requirements engineers will rule in the near future.

- Molecular programming
  - Creates synthetic nanosystems that aseemble themselves from molecular
    components.
  - Can be done by carefully choosing the molecular strands and concentrations.

- Example: programmable bio-sensor
  - "Pliers" that go from open to shut when a specific target module is present

- 2009: Box with controllable lid (Andersen et al, Nature)
- 2011: Molecular calculation of square root of 4-bit numbers (Qian and Winfree)
- 2011: Simulate digital signals (Qian and Winfree)

- How to do this:
  - Agree on intent (requirements)
  - Do detailed design using software tools
  - Compile into DNA strands
  - Order strands online
  - Implement system in lab (prepare, mix, heat, cool)
  - Test/observe results
  - Debug and repeat

- Safety-critical applications:
  - Medical
  - Biosensors
  - Drug delivery
  - Picture: DNA nanorobot, with atomic force microscope

- Applying requirements engineering
  - Problem: Hard to monitor when an event occurs (or doesn't occur!) in a DNA
    nanosystem
  - Solution: Use a molecular watchdog timer

- Why use requirements engineering
  - To make things right.

- Debugging the requirements
  - False positive risk? Yes.
  - Likely and critical: Dog barking too much will flood the system with alarm
    molecules

- Probabilistic model checking
  - PRISM
  - STOCHASTIC MODEL CHECKER

- LAMP: Laboratory for Molecular Programming at ISU

## 10. Prototyping

- Presentation prototypes
- Exploratory prototypes
- Breadboards or experimental prototypes
- Evolutionary prototypes

### SPRINT rules

- 1. The Facilitator is in charge of the schedule.
- 2. The Decider makes all tough decisions.
- 3. No devices in the room.
- Monday: Map.
  - Make a map of the workflow as it exists.
  - Rephrase problems as opportunities
  - Pick a target
- Tuesday: Sketch.
  - Group brainstorms don't work. Sketch alone.
  - Sketches typically simple on sticky notes.
- Wednesday: Decide.
  - Fast decisions
  - No groupthink
  - No sales pitches
  - Turn winning sketches into storyboard
- Thursday: Prototype.
  - Make a realistic facade with Powerpoint or something.
  - Mock out services with actors.
- Friday: Test.
  - Five interviews are enough to reveal big patterns.
  - Fix shit
  - Subsequent consecutive sprints are faster

### Examples

- Flatiron Health example

- Savioke Labs example
  - Hotel robots
  - Fast Company article "How Savioke Built a Robot Personality in 5 Days"

- Slack example
  - How to explain Slack to non-techies?

- Crazy Eights
  - Everyone spends five minutes to create six screens

- F-Layout design
  - Eye scanning pattern

<!-- 2018 Jun 12 -->

## 11. Quality requirements

- What would you look for when buying a new car?
  - HP, engine reviews, price, style, brand recognition, fuel efficiency, size,
    insurance rates
- These are all quality requirements.

- WHEREAS, functional requirements are
  - what the software is supposed to do
  - are either satisfied or not

- Quality requirements
  - describe additional constraints that measure the quality of a solution
  - are often, but not necessarily, but preferably, quantitative

- Car functional requirements:
  - Airbags, active safety features, cup holders, move people over a distance,
    AWD

- Examples of quality requirements:
  - Performance
  - Reliability (no problems with software)
  - Robustness (no problems if input has problems)
  - Adaptability
  - Security
  - Usability
  - Scalability
  - Efficiency
  - Accuracy, precision

- Other nonfunctional requirements:
  - Design constraints
  - Operating constraints
  - Product-family requirements
  - TODO

- Motherhood requirements:
  - Requirements that people obviously want, so no need to ask
  - What's important is relative importance.
  - "reliable", "user-friendly", "maintainable"

- Fit criteria:
  - Criteria that quantify the extent to which a quality requirement must be
    met.
  - Examples:
    - No more than 5 minutes of downtime a year.
    - 75% of users judge the system as usable.
    - After training, 90% of users can process new account within 4 minutes
  - Some can't be tested before delivery. Must measure indirectly.

- Monte carlo techniques: Estimate unknown using known quantity by lots of
  random simulation

- Paper airplane exercise:
  - Degrades slowly with use -> Usable more than once.
  - Flight time. - 15s
  - Predictable flight path. -> Same pattern when thrown every time.
  - Goes fast. -> 5m/s
  - Looks cool. -> 50% of users recommend looking at it
  - Not expensive. -> Less than $1

- Many quality attributes typically conflict.
  - e.g. Efficiency neg Interopability
  - e.g. Reliability pos Availability

- Rich fit criteria
  - Range of satisfaction
  - Example:
    - Requirement,   Outstanding, Target, Minimum
    - Response time, 0.1s,        0.5s,   1s
    - CPU util,      20%,         25%,    30%
    - Usability,     40 tasks/hr, 30,     20
  - Value to user in terms of quality attributes is a sigmoid curve.
    Diminishing returns are a thing.

<!-- 2018 Jun 14 -->

## 12. Prioritizing requirements

- Descoping
  - Rapid descoping phase: quickly reducing the scope of a project, usually to
    meet a release date

- Priority
  - Can be: relative importance
  - Can be: precedence, ordering

- Prioritization criteria
  - Examples:
    - Business value added
    - Penalty/harm avoided
    - Risk
    - Cost
    - Time
  - Can prioritize according to cost-value ratios

- Grouping requirements
  - By priority: Critical, Standard, Optional
  - Problem: Stakeholders will say that everything is critical. (typically,
    85%)

- Ranking requirements
  - Can totally order your requirements, but it's hard to see relative
    differences this way.

- 100 dollar test (aka: cumulative voting)
  - Stakeholders are given 100 prioritization points to distribute among the
    requirements.
  - Total dollar amount gives you an idea of relative importance.

- Kano model
  - Graph of satisfaction as a function of execution quality.
  - y=x: Performance. Requirements the customer specifically asked for.
  - Sell put payoff: Basic. Requirements the customer takes for granted.
  - Buy call payoff: Excitement. Delightful features the customer does not
    request or expect.
  - y=0: Indifferent. Requirements the customer does not care about.

- Kano surveys
  - "How would you feel if the requirement were included?" (Functional)
  - "How would you feel if the requirement were NOT included?" (Dysfunctional)
  - Answers:
    - I like it
    - I expect it
    - I am neutral
    - I can tolerate it
    - I dislike it
  - Table from answers to basic/performance/excitement/indifferent.
    - Other possibilities: questionable, reverse.
  - Implement Basic first, then Performance, then Excitement, then Indifferent.
  - Example: MathNEWS interactive

- Categorization plane
  - To combine multiple surveys, use values of -2, -1, 0, 2, and 4. Then
    categorize using the quadrants of [0,4]².

- Analytic Hierarchy Process
  - Analyzes stakeholders' pairwise comparisons of requirements.
  - Scores: 1, 3, 5, 7, 9
    - 1: equal value, 9: extremely preferred
    - Use even numbers when you need compromise
  - At row Req1 and col Req2 of a matrix, put score of how much Req1 is
    preferred over Req2. If inverse, then use 1/score.
  - Estimate eigenvalues by normalizing columns, sum the rows, then normalize
    overall
  - Can check consistency by:
    - 1. Multiply comparison matrix with priority vector
    - 2. Pointwise divide result by priority vector
    - 3. Take average to get principle eigenvalue
    - 4. Compute consistency index CI = (4.37 - n)/(n-1)
    - 5. CR = CI/0.90. Want CR < 0.10.

- Combining different techniques
  - Plot ROI ratio on a common graph

<!-- 2018 Jun 19 -->

## 13. Risk management

- Risk: Potential for loss

- Risk exposure: criticality(risk) = likelihood(risk) * consequences(risk)

- Risk consequence table
  - Horizontal axis: Risks and likelihoods.
  - Vertical axis: Requirements and weights.
  - Middle: Estimate of impact of risk on requirement (0.0-1.0)
  - Bottom: Total risk criticality.
  - Right: Loss of objective.

- Risk countermeasures table
  - Horizontal axis: Risks and likelihoods.
  - Vertical axis: Countermeasures.
  - Middle: Estimate of reduction on risk.
  - Bottom: Combined risk reduction.
  - Right: Overall single effect of countermeasure.

- Formulas
  - criticality = likelihood * consequences
  - consequences = sum over reqs of impact(req, risk) * weight(req)
  - tall poles - highest criticality
  - loss(req) = sum over risks of impact(req, risk) * likelihood(risk) * weight(req)

<!-- 2018 Jun 21 -->

## 14. Specifications

- Overview of module
  - Deriving specs from reqs
  - Spec, Dom ⊧ Req
  - Domain model for specs

- Example: Lufthansa Flight DLH 2904
  - Req: Reverse thrust enabled iff aircraft is moving on the runway
  - -> System Spec: reverse thrust enabled iff wheel pulses are detected
  - Assumptions made:
    - 1. Aircraft is moving on the runway iff wheels are turning
    - 2. Wheel sensor detects pulses iff wheels are turning
  - Assumption 1 didn't hold; wheels hydroplaned

- Environment v. System model
  - (Environment [Interface) System]
  - Environment contains requirements
  - Specification is fully about the interface

- Assumptions
  - Ideally, we want to show that the specifications imply the requirements:
  - Spec ⊧ Req
  - Often, we cannot do so without making some assumptions about the environment.
  - Dom subseteq Env

- Example: Park User Fees
  - Reqs:
    - R1: Collect $1 fee from each user on entry to the park.
      - Interface: Coin slot
      - Spec:
        - (Env) coin inserted into slot
        - (Sys) senses coin
    - R2: Ensure that anyone who has paid may enter the park.
      - Interface: Turnstile
      - Spec:
        - (Sys) unlock turnstile upon sensing a new coin
        - (Env) visitor pushes unlocked turnstile
    - R3: Ensure that no one may enter park without paying.
      - Interface: Turnstile
      - Spec:
        - (Sys) detect entry
        - (Env) relock turnstile
  - Assumptions:
    - Dom
      - (1) Coins are $1
      - (2) Person who paid is the person who enters
      - (3) Only 1 person enters when the gate is nocked
    - Spec
      - (1-2) Coin slot accepts $1 and opens gate
      - (*) After 1 entry, gate is relocked
    - Req
      - (1) Gate, fence, coin slot
      - (2) Honour system, collection box
      - (3) Manned kiosk

- Example: Thermostat
  - R: Want to keep the air temperature at or above the user-defined temperature.
  - Interface devices:
    - Thermometer
    - UI for user to set
    - AC, furnace
  - Spec:
    - If UI-set temp > thermometer temp then turn on AC
  - Assumption:
    - AC on cools the air temperature

- Example: Elevator

- Deliverable
  - A Scenario is a path through the activity diagram
  - Classic mistake:
    - Writing assumption that really reflects a responsibility of the system

- Domain models
  - Diagrams that capture requirements and specifications
  - Requirements only captures environment
  - Specifications also includes «interface»s and parts of the system

- Domain models should have:
  - Attributes
  - **Multiplicities on all associations**
  - Association names, role names
  - Qualifiers to simplify multiplicities on associations
  - Actors, as stick figures or «actor» classes
  - For specifications: Interface devices as «interface» classes

- Domain models should not have:
  - Class-level operations, methods
  - Visibility annotations (private, protected, public)
  - Navigability arrows
  - Attributes types, initial values (unless needed for model correctness)
  - Object construction and destruction functions

- Thank you for coming on a day you have a midterm
- Tuesday: OCL (Object Constraint Language)

<!-- 2018 Jun 26: Skipped (business rules, OCL) -->
<!-- Notes taken after -->

- OCL: Object constraint language.
  - A rigorous language for expressing business rules over UML models

- Example:
  - `context Person inv: self.RentalAgreement.Vehicle->size() <= 3`

- Traverse using dot. Traversing across relations with multiplicities
  automatically turns the result into a Set or Bag.

- Basic OCL types: Booleans, Integers, Reals, and Strings.

- See table of operations on these types. Here are some:
  - On Booleans: `or, and, xor, not, =, <>, implies, if x then y else z`
  - On Strings: s.concat(t), s.size, s.toLower, s.toUpper, s.substring(a,b), =,
    <>
  - On numbers: `=, <>, <, >, <=, >=, +, -, *, /, .mod(), .div(), .abs, .max(),
    .min(), .round, .floor`

- OCL expressions on collections are denoted using `->`.

- Some OCL expressions can filter collections, or quantify over them. For example,
  - `context RentalCarCompany inv: self.owns->select(colour="red")->isEmpty()`
  - Others: reject, collect, exists, forAll, 

<!-- 2018 Jun 28: Skipped (conflict management) -->

- Data conflict: People understand the issue differently
  - e.g. We want to track student attendance, but there is no room to record
    attendance on a transcript
- Interest conflict: Stakeholders have different goals or interests
  - e.g. Province wants to track student attendance for accounting; students
    say no because privacy
- Value conflict: Stakeholders have different preferences
  - e.g. Engineering faculty wants to rank students, students think that
    rankings are too fine-grained

- Group resolution strategies: TODO
- Individual resolution strategies: TODO

<!-- 2018 Jul 03 -->

## State machines

- They're just the FSMs you konw

- UML state machines:
  - States are equivalence classes of input traces
  - Inputs are events and conditions on «interface» phenomena
  - Outputs are actions on «interface» phenomena
  - Can have internal variables

- States:
  - Pseudo-states: Start and end markers

- Transitions:
  - event(args)
  - [condition]
  - /action

- Events:
  - Absolute time events:
    - at (12:12pm)
  - Relative time events:
    - after (10 seconds since x)
    - after (20 minutes) // since source state was entered
  - Change events:
    - when (temperature > 100 degrees)
    - Only when a change happens.

- Stopwatch example

- Checking for completeness
  - For all states X and events e, must have:
    - Transition on e from state X
    - OR, e cannot physically occur in state X
      - No transition needed
    - OR, e is possible but system should ignore it
      - No transition needed
    - OR, e is possible in state X, but system should report an error
      - Transition needed in this case

- Hierarchical states
  - Transitions into the boundary start in the child's starting state.
  - Transitions into a particular substate go to that substate.
  - Transitions from a child apply to all states within the child.
  - Determinism: At most one transition should be able to happen with a single
    event.
  - Priority: Nested states have priority (???)
  - Priority: Simultaneous events don't happen

<!-- 2018 Jul 03 -->

- History
  - Pseudo-state that returns you to the previous sub-state you were in.
  - Arrow out of history is the default state if there is no history.

- Deep history
  - Pseudo-state that transitions you to the deepest descendent state when you
    last exited.
  - To check your understanding: on the deep history slide, what sequence of
    events does something different than if it's plain history?
    - y,t,x,z

## State machines (2)

- Concurrent regions
  - Model orthogonal behaviours as separate, concurrently running state
    machines. Can be embedded in an outer FSM. All submachines must reach their
    final state before outer machine continues.

- Example in slides:
  - Start state: E/F
  - x: D/F
  - p: A
  - r: E/F
  - m: E/F
  - s: A/J
  - q: f1/f2 -> (H) -> A

- Termination state
  - X-shaped state that shows the machine is ded
  - In a concurrent region, this kills the entire machine; doesn't just show
    that the concurrent region finished

- State actions
  - Actions are uninterruptible, so you can do them upon transitions into or
    out of certain states
  - Entry action: entry/x
  - Exit action: exit/y
  - Internal action: ev[cond]/z
  - Execution order:
    - 1. Exit actions of source state
    - 2. Transition actions
    - 3. Entry actions of destination state
    - 4. State activities

- How to create a behaviour model
  - Identify input and output events
  - Identify:
    - Activity states, where the system performs an activity or operation
    - Idle states, where the system waits for input
    - System modes, where you use different states to distinguish different
      reactions to an event
  - Consider system behaviour for each input at each state.
  - Revise using hierarchy, concurrency, or state events.

<!-- 2018 Jul 10 -->

- Validating behaviour models
  - Avoid inconsistency: No duplicate transitions
  - Ensure completeness: Every possible input is handled
  - Walkthrough: Simulate use cases

## Guest lecture: Role of requirements in a consulting environment

- James Corr: SE2018
  - Runs Shopify consulting company in Kitchener
  - 2009: Top 10 FB app, several million installs, sold
  - 2005: Started web consulting
  - 2015: Rank 15/450 Shopify app, 4k paying customers each paying $10-20/mo in
    10 months from idea stage
  - customers: Fashion Nova, RageOn, MVMT, Bulletproof, RadioShack

- Stakeholders
  - In consulting, time is money
  - Engineers love to play video games, but that's not profitable. Make sure
    engineers have something to do.
  - Decision Maker may not be the Point of Contact.
  - Limit Point of Contact
    - Point of Contact can change

- Why getting requirements is hard
  - Story: "Where's my UK site?"
  - $500/hr consultants know what questions to ask.
  - 70% of subscriptions unsubscribe right away, given a 10% discount on
    subscription.
  - Sometimes, client will say "I want this really specific thing". Later you
    ask "why do you want this?" and realize that they were bad.

- Comparison: before
  - Agency rate $120/hr
  - Designer: $40/hr
  - Junior engineer: $18/hr
  - Senior engineer: $70/hr
  - Project manager: $25/hr
  - Typical project flow:
    - Project manager talks high level
    - Ask engineers for estimate
    - Multiply estimate by 1.25x and quote client
    - Design assets as needed/requested
  - Result:
    - All nighters, having to pay staff, fixed-bid so can't get paid by client
    - 32% of clients didn't pay on time
    - 20% of time work was not billed for (no handling of scope creep)
    - bad

- After:
  - Agency rate $225/hr
  - Designer: $60/hr
  - Junior engineer: $25/hr
  - Senior engineer: $100/hr
  - Project manager: $50/hr
  - Typical project flow:
    - 2-4 weeks collecting requirements
    - Per-engineer estimate multipliers
    - 15% contingency budget
    - Iterations of wireframes and mockups
  - Result:
    - Staff not overworked
    - Happier atmosphere
  - Stats
    - 2% of clients didn't pay on time
    - 5% of time work not billed for (use contingency fund)
    - 0hr of underutilized time per week
    - 31.1% profit margins
  - Top 10 agencies:
    - $150-175/hr
    - 20% profit margins

- Where to get requirements?
  - Similar site builds from the past
  - Explain similar company problems you've worked on
  - Questionnaires
  - Brainstorm
  - Wireframes
  - Mockups
  - Demos
  - Third-party integrations
  - Do as much research on your own before wasting the company's time

- Collecting better requirements
  - Ask open, non-leading questions
  - Ask "what" and "why" a LOT
  - Listen. Interviews should be 20% you, 80% them
    - Becomes more equal over time
  - Speak with non-decision makers like engineers and warehouse managers
  - Employees can be scared to answer when manager is present
  - Employees can be scared if you're about to eliminate their job

- Understand the key problems
  - "I want to move from Magento to Shopify."
  - Ask why.

- Scope creep is real
  - Add a contingency fund
  - Build v2 list before building v1
  - v1 is MVP to launch

- QA and post-launch bugs
  - n days of responsibility
  - Monte Carlo technique: Make junior developers and clients do QA and see if
    they report the bug.
  - UserTesting.com
  - HotJar.com for mouse movements, heatmaps

- Tradeoffs
  - Balance: design or conversion

- Terms in contract
  - Send invoice zeroed out
  - Single domain only
  - No instructions or training
  - Two minor changes
  - Exclusivity
  - Not responsible for data migration delays
  - Not responsible for middleware software you create
  - 13 pages listing many obvious things

## 18. Temporal logic

- Temporal constraints are constraints over execution traces
- Examples:
  - Dialing a valid number **always** results in either the call being
    connected or a busy-tone.
  - An elevator **never** moves with its doors open.
  - If a car approaches the intersection, the light in its direction will
    **eventually** be green.

- Predicate logic: ∀, ∃ are things
- Examples:
  - Every student who has money goes to the movies.
    - ∀s:Student | money(s) ⇒ movies(x)
  - Some student has money and goes to the movies.
    - ∃s:Student | money(s) ∧ movies(x)

- Executions
  - Variables change over time as the state advances.
  - A sequence of states σ = s₀,s₁,s₂,...

- State formula: Predicate logic property that is evaluated wrt a particular
  execution state.
- e.g. s ⊧ Engine.moving ⇒ Door.closed

- Timed logics
  - Two options.
  - 1. Make time explicit. Make all variables functions over time.
  - 2. Use a TEMPORAL LOGIC to relate variables a different execution states.

- Turnstile example.
  - 1. The number of entries into the park is ALWAYS at most the number of
       coins received.
    - ∀t:Time | numEntries(t) ≤ numCoins(t)
  - 2. If a visitor pushes the turnstile and the turnstile is unlocked, then
       the visitor will ALWAYS eventually enter the park.
    - ∀t:Time | push(t) ∧ ¬locked(t) ⇒ [∃t':Time | t' > t ∧ enter(t')]
  - 3. If a visitor pushes the turnstile when the turnstile is unlocked, then
       the turnstile will rotate until the visitor enters the park.
    - ∀t:Time | push(t) ∧ ¬locked(t) ⇒ [∃y:Time | y > t ∧ entry(y) ∧ (∀z:Time | x ≤ z < y ⇒ rotating(z))]

<!-- 2018 Jul 12 -->

- Explicit vs. implicit time
  - Explicit time: Computations involving times and spans
  - Implicit time: Relative ordering of events

- LTL semantics
  - σ ⊧ f iff (σ,0) ⊧ f
  - ⊧ f iff f is true in state s0 of all executions σ

- Temporal connectives
  - Shorthands for quantifications over future states
  - Henceforce: ⌷
    - ⌷f means "f is true in the current and all future states"
    - (σ,j) ⊧ ⌷f iff ∀ k| | j ≤ k ⇒ (σ,k) ⊧ f
  - Eventually: ⋄
    - ⋄f means "f is true in the current or some future state"
  - Next state: O (circle)
    - Of means "f is true in the next future state"
    - (σ,j) ⊧ Of iff (σ, j+1) ⊧ f
  - Until: u (cursive)
    - f u g means "g is eventually true, and f is true until g is true"
    - (σ,j) ⊧ f u g iff ∃k | j ≤ k ∧ (σ,k) ⊧ g ∧ ∀i | j ≤ i < k ⇒ ((σ,i) ⊧ f)
    - Note: (f u g) implies ⋄g
  - Unless: w (cursive)
    - f w g means "f is indefinitely true, or f is true until g is true"
    - f w g iff ⌷f or f u g
    - Until often used for system properties; unless often used for
      environmental properties

- Examples
  - It's always the case that the number of entries in the park is less than or
    equal to the number of coins received.
    - ⊧ ⌷ (numentries ≤ numcoins)
    - means: ∀σ:(σ,s0) ...
  - ⋄(⌷f): f will always hold from some point on
  - ⌷(⋄f): f will always happen some time in the future
  - Henceforth, if the barrier is pushed when the barrier is unlocked, then in
    the next state the barrier will be rotating until the visitor has entered.
    - ⊧ ⌷((push ∧ ¬locked) ⇒ O(rotating) u enter)
  - Henceforth, if the turnstile is locked, then it will stay locked unless a
    coin is entered

- Elevator examples
  - 1. The elevator shall never move with its doors open.
    - ⊧⌷(moving ⇒ door=closed)
  - 2. The elevator shall not keep its doors open indefinitely.
    - ⊧⌷(door=open ⇒ ⋄(door=closed))
  - 3. The elevator does not move before a request is made.
    - ⊧⌷(¬moving w ∃i:1..5(req(i)∧floor≠i))

- Tautologies
  - Op ⇒ ⋄p
  - f u g ⇒ ⋄g
  - g ⇒ f u g
  - f ∧ Og ⇒ f u g

- LTL and Finite State Machines
  - first false??
  - second true??
  - third false (missing a "next state")
  - Entire machine can be modelled using LTL formulae

- Model checking  
  - Formal verification technique that checks whether an FSM satisfies a temporal logic property.
  - First way they did it
    - They took a formula and broke it down into simplest possible subformulae
    - For every state, check if the subformulae hold
    - So, states are labelled based on which variables hold in that state
    - Reconstruct originally desired formulae

- Example: US navy aircraft A-7E
  - Was a state machine requirements model with three subsystems (navigation,
    navigation update, weapon delivery)

- Model checking happens a lot for hardware.

<!-- 2018 Jul 17 -->

## 19. Software estimation

- CAATS timeline
  - 1989 Nov: Treasury Board approves CAATS. Fixed-price contract with price
    ceiling of $465.6M.
  - 1990: Transport Canada rejects first major milestone (contractor's proposal
    of new system)
  - 1994 Dec: Agreement still not reached. $230M already paid out.
  - 1995 Sep: Treasury Board approves substantially amended project.
    - Instead of 60 towers, 23 towers
  - 1996 Sep: Contract re-renegotiated
  - 2000 Dec: CAATS delivered to NAV Canada

- Why estimate?
  - Assess feasibility
  - Understand needs
  - Provide basis for agreeing to a job
  - Make meetable commitments

- Terminology
  - Estimate: Prediction of project duration or cost.
    - Function of:
      - Feature set
      - Schedule
      - Quality
  - Target: Statement of business objective.
  - Commitment: Promise to deliver.

- Inaccurate estimates
  - "An estimate is the most optimistic prediction that has a non-zero
    probability of coming true."
  - Pricing to win: Undercutting the competition to win a contract.
  - Parkinson's law: "Things will take you the amount of time that you have."

- Costs of overestimation
  - Risk of losing contract
  - Risk of others underestimating your estimates
  - Parkinson's law

- Costs of underestimation
  - Not getting enough resources
  - Project problems
  - Extra work once target is missed
  - Better to err on the side of overestimation

- Industry's track record on projects
  - Big projects fail, are late, and are over budget more than small ones.

- Sources of estimation error
  - Omitted activities
    - Initialization
    - Data conversion
    - Glue code
  - Software development activities
    - Integration
    - Test data
    - Performance tuning
    - Technical reviews
  - Non-development activities
    - Vacations
    - Sick days
    - Training
    - Meetings
  - Optimism
    - Research shows optimism of about 20-30%
    - Managers tend to cut subsequent estimates by 30%, believing people learn
  - Bias
    - Managers want to put pressure on workers to make things happen faster
  - Subjectivity

- Uncertainty of estimation decreases quickly over time. From 0.25x-4x for the
  initial concept, to 0.8x-1.25x when UI is complete.

- Biggest influences on estimates
  - Project size: Diseconomies of scale
  - Kind of software
  - Personnel factors. Individiaul productivity can vary by orders of
    magnitude.

- Estimates using data
  - Take into account past projects:
    - Project size (LOC, requirements)
    - Effort (staff months)
    - Time (calendar months)
  - Can also take data from:
    - Project data (data from the current project)
    - Historical data (data from the company)
    - Industry data (data from other similar organizations)

- Estimation by analogy
  - Compare old projects with your old project and apply a multiplier depending
    on how many MORE lines of code etc. your new project needs

- Lines of code "examples":
  - Space Shuttle (primary flight software): 400k
  - LibreOffice: 9.1M
  - Android: 12M
  - Beoing 787 Dreamliner: 14M
  - Microsoft Office: ~45M
  - Ford F150 Truck: 150M
  - Debian 5.0: 324M
  - Healthcare.gov: 500M
  - All of Google's internet services: 2B

- Function point analysis
  - 1. Estimate # of function points from requirements
  - 2. Estimate code size from function points
  - 3. Estimate resources required from code size

- Function point
  - "Points" for how complex your code might be
  - Counted based on:
    - External inputs: screens, forms, dialog boxes, messages
    - External outputs: screens, reports, graphs, messages
    - External queries: input requests that don't change the system data
    - Internal logical files: internal data stores
    - External interfaces / APIs
  - Complexity multipliers (low, med, high) are:
    - 3,4,6
    - 4,5,7
    - 3,4,6
    - 4,10,15
    - 5,7,10
  - Somehow this has been standardized, and there are certifications for
    knowing this

- Structured expert judgment
  - A last resort, apparently
  - Ask people who will actually be doing the work
  - PERT: Program evaluation and review technique
    - ExpectedCase = (BestCase + 4×MostLikelyCase + WorstCase)/6

- Summary of size estimation technology:
  - Size estimation
    - Analogy
    - Estimation tools
    - Function point analysis
    - Structured judgement
    - PERT
    - Commercial tools
  - Effort estimation
    - Analogy
    - ISBSG
    - Industry Data
    - Commercial tools
  - Schedule estimation
    - Basic sschool equation
    - Analogy

- Estimating effort
  - Informal comparison to past projects:
    - Effort = PastEffort × Size/PastSize
  - ISBSG (International Software Benchmarking Standards Group) Method
    - Allows you to compute StaffMonths based on FunctionPoints and MaxTeamSize
      for:
      - Desktop projects
      - Enhancement
      - New development
      - Third generation language project
      - Fourth generation language project

<!-- 2018 Jul 24 -->

## Final review

- Business requirements
  - Know your business objectives and stakeholder types. Recall the lean canvas
    business model, hypothesis tests, and stakeholder analysis.

- User requirements
  - Know context diagrams, use-case diagrams, and user stories.

- Elicitation
  - Know how to elicit requirements from users.
  - Draw an activity diagram and a data-flow model. Write scenarios. Devise
    quality requirements for a system.

- Requirements analysis
  - Know how to resolve conflicts.
  - Perform a prioritization technique, a risk analysis, and a software estimation.

- Requirements and specifications
  - Understand functional requirements, environment vs. interface, and
    assumptions
  - Derive specs from requirements
  - Identify assumptions such that spec will meet reqs

- Modelling and documentation
  - Know UML, state machines, OCL, temporal logic, navigation maps

- Guest lectures
  - Shyam Sheth: RE for entrepreneurial projects
  - Robyn Lutz: RE for safety critical systems
  - James Corr: RE in consulting projects

- Entrepreneurial products
  - Business model → User stories → Prototypes → Navigation map

- The Problem Lab
  - All about entrepreneurs who can create ventures of great economic and social consequence.
  - Make sure you're developing something of value.
  - MAKE SOMETHING PEOPLE WANT MAKE SOMETHING PEOPLE WANT MAKE SOMETHING PEOPLE
    WANT MAKE SOMETHING PEOPLE WANT MAKE SOMETHING PEOPLE WANT MAKE SOMETHING
    PEOPLE WANT MAKE SOMETHING PEOPLE WANT

- Final exam:
  - About 4/5 application questions, 1/5 comprehension and short-answer
  - Must pass

- MBET students had totally infeasible or totally simple ideas
  - They did not have the capacity to think
