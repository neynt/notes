# SE 464: Software architecture

Professor: Werner Dietl

## 2: Architecture

- How to choose between alternatives
  - Fitness for purpose
  - Cost of production (parts, labour, capital)
  - Cost of operation
  - Fitness for future
- Architecture dimensions:
  - Structure
  - Communication
  - Nonfunctional requirements
- Eoin Woods: Software architecture is the set of design decisions which, if made incorrectly, may cause your project to be cancelled.
- A **functional requirement** (FR) is what the system has to do.
- A **nonfunctional requirement** (NFR) is how well the system is at being a system.
- System architecture stakeholders: Architects, Developers, Testers, Managers, Customers, Users, Vendors.
- Only **principal** design decisions affect the architecture.
- Architecture consists of processing, data, and interaction.
- Types of connectors:
  - Procedure call
  - Shared memory
  - Message passing
  - Streaming
  - Distribution
  - Wrapper/adaptor

## 3: Architecture and nonfunctional properties

- Non-functional properties
  - **Efficiency**
  - **Complexity**
  - **Scalability**
  - **Heterogeneity**: has disparate parts
  - **Portability**: can execute on multiple platforms
  - **Evolvability**: can satisfy new stuff
  - **Dependability**: reliable (won't fail), available, robust, fault-tolerant, survivable, safe
    - topology: no single points of failure. backups, monitoring, adaptation.

## 4: Nonfunctional properties

- An **architectural pattern** is a set of design decisions
- Examples of patterns:
  - Three tiered system (Frontend, App, and Database)
  - Model view controller
  - Sense compute control
- An **architectural style** is kind of like a set of design decisions that are generally good
- A **pure** architectural style is rarely used.
- Examples of styles:
  - Layered
    - e.g. Client/server, Virtual machine
    - Each layer exposes an API to be used by layers above
    - Examples: operating systems, OSI 7 layers
    - Advantages: increasing abstraction levels, evolvable
    - Disadvantages: not universally applicable, performance
    - Client-server
      - Components are clients and servers
      - Servers don't know clients; clients know servers
      - RPC
    - Virtual machine
  - Dataflow
    - Batch sequential
      - Programs executed in order
      - Like pipe and filter but each component must process ALL its input
    - Pipe and filter
      - Process data streams
      - Components are filters
      - Connectors are pipes
      - Examples: UNIX shell, D S P, distributed systems, parallel programming
  - Shared memory
    - Blackboard
      - Central data repository, and components operate on it
      - Examples: AI, IDEs, compilers
    - Rule-based
      - Inference engine distinguishes facts and queries
      - Example: P R O L O G
  - Interpreter
    - Interpreter
      - Exactly what you think it is, like Python
    - Mobile code
  - Language-based
    - Object-oriented
    - Procedural
  - Peer-to-peer
    - Like bittorrent. M e s h  networks
  - Implicit invocation
    - Pubsub
      - Separate publishers and subscribers
    - Event-based
      - Everyone can publish and receive events
- CORBA
  - Common Object Request Broker Architecture
  - (tbh: good idea, ruined by design by committee)
- Summary:
  - These are pure styles
  - Architectures can differ even for the same style, and styles can be combined
- Design recovery: Getting architecture from code base
  - Syntactic clustering
    - Static analysis
    - May miss relationships from dynamic information
  - Semantic clustering
    - Dynamic analysis
    - Oft requires human understanding
- Greenfield design: this is us. You Make Everything!

# 7: Modeling

- Model: Set of all design decisions that comprise system architecture
- What do we model?
  - Components
  - Connectors
  - Interfaces
  - Configurations
  - Rationale
- Static vs. dynamic aspects
  - Static aspects do not change as the system runs
  - Dynamic do
- Functional vs. non-functional aspects
  - Functional: "The system does it"
  - Non-functional: "The system does it well in these ways"
- Models should be:
  - Unambiguous (No more than one interpretation)
  - Accurate (Correct)
  - Precise (Not ambiguous)
- Views and viewpoints:
  - Versions of the model that capture the design decisions from a particular perspective
- Viewpoints:
  - Logical
  - Physical
  - Deployment
  - Concurrency
  - Behavioral
- **Consistent** views don't disagree with each other
  - Common inconsistencies:
    - Direct (e.g. 2 vs. 3)
    - Refinement (high-level and low-level disagree)
    - Static vs. dynamic
    - Dynamic vs. dynamic: e.g. state vs. sequence diagram
    - Functional vs. non-functional
- Evaluating modeling approaches
  - Scope and purpose
  - Basic elements
  - Style
  - Static and dynamic aspects
  - Dynamic modeling
  - Non-functional aspects
  - Ambiguity
  - Accuracy
  - Precise
  - Viewpoints
  - Viewpoint consistency
- Modeling approaches:
  - Generic approaches (Natural language, Powerpoint, UML)
  - Early architecture description languages (Darwin, Rapide, Wright)
  - Domain- and style-specific languages (Koala, Weave, AADL)
  - Extensible architecture description languages (Acme, ADML, xADL)
- UML:
  - 13 notations
  - For static and dynamic aspects
  - Advantages:
    - Support for diverse array of viewpoints
    - Common
    - Tool support
  - Disadvantages:
    - Needs customization to reduce ambiguity
    - Hard to determine if views are consistent
    - Hard to capture foreign concepts/views
  - Static structures:
    - Component diagrams
    - Deployment diagrams
    - Class diagrams
  - Dynamic behavior:
    - Sequence diagrams
    - Use case diagrams
    - State machine diagrams
 Architecture description languages
  - Entire programming languages made not for writing programs, but for describing them
