# SE 464: Software architecture

Professor: Werner Dietl

## 2: Architecture

- How to choose between alternatives
  - Fitness for purpose
  - Cost of production (parts, labour, capital)
  - Cost of operation
  - Fitness for future
- Architecture dimensions:
  - Structure
  - Communication
  - Nonfunctional requirements
- Eoin Woods: Software architecture is the set of design decisions which, if made incorrectly, may cause your project to be cancelled.
- A **functional requirement** (FR) is what the system has to do.
- A **nonfunctional requirement** (NFR) is how well the system is at being a system.
- System architecture stakeholders: Architects, Developers, Testers, Managers, Customers, Users, Vendors.
- Only **principal** design decisions affect the architecture.
- Architecture consists of processing, data, and interaction.
- Types of connectors:
  - Procedure call
  - Shared memory
  - Message passing
  - Streaming
  - Distribution
  - Wrapper/adaptor

## 3: Architecture and nonfunctional properties

- Non-functional properties
  - **Efficiency**
  - **Complexity**
  - **Scalability**
  - **Heterogeneity**: has disparate parts
  - **Portability**: can execute on multiple platforms
  - **Evolvability**: can satisfy new stuff
  - **Dependability**: reliable (won't fail), available, robust, fault-tolerant, survivable, safe
    - topology: no single points of failure. backups, monitoring, adaptation.

## 4: Nonfunctional properties

- An **architectural pattern** is a set of design decisions
- Examples of patterns:
  - Three tiered system (Frontend, App, and Database)
  - Model view controller
  - Sense compute control
- An **architectural style** is kind of like a set of design decisions that are generally good
- A **pure** architectural style is rarely used.
- Examples of styles:
  - Layered
    - e.g. Client/server, Virtual machine
    - Each layer exposes an API to be used by layers above
    - Examples: operating systems, OSI 7 layers
    - Advantages: increasing abstraction levels, evolvable
    - Disadvantages: not universally applicable, performance
    - Client-server
      - Components are clients and servers
      - Servers don't know clients; clients know servers
      - RPC
    - Virtual machine
  - Dataflow
    - Batch sequential
      - Programs executed in order
      - Like pipe and filter but each component must process ALL its input
    - Pipe and filter
      - Process data streams
      - Components are filters
      - Connectors are pipes
      - Examples: UNIX shell, D S P, distributed systems, parallel programming
  - Shared memory
    - Blackboard
      - Central data repository, and components operate on it
      - Examples: AI, IDEs, compilers
    - Rule-based
      - Inference engine distinguishes facts and queries
      - Example: P R O L O G
  - Interpreter
    - Interpreter
      - Exactly what you think it is, like Python
    - Mobile code
  - Language-based
    - Object-oriented
    - Procedural
  - Peer-to-peer
    - Like bittorrent. M e s h  networks
  - Implicit invocation
    - Pubsub
      - Separate publishers and subscribers
    - Event-based
      - Everyone can publish and receive events
- CORBA
  - Common Object Request Broker Architecture
  - (tbh: good idea, ruined by design by committee)
- Summary:
  - These are pure styles
  - Architectures can differ even for the same style, and styles can be combined
- Design recovery: Getting architecture from code base
  - Syntactic clustering
    - Static analysis
    - May miss relationships from dynamic information
  - Semantic clustering
    - Dynamic analysis
    - Oft requires human understanding
- Greenfield design: this is us. You Make Everything!

## 7: Modeling

- Model: Set of all design decisions that comprise system architecture
- What do we model?
  - Components
  - Connectors
  - Interfaces
  - Configurations
  - Rationale
- Static vs. dynamic aspects
  - Static aspects do not change as the system runs
  - Dynamic do
- Functional vs. non-functional aspects
  - Functional: "The system does it"
  - Non-functional: "The system does it well in these ways"
- Models should be:
  - Unambiguous (No more than one interpretation)
  - Accurate (Correct)
  - Precise (Not ambiguous)
- Views and viewpoints:
  - Versions of the model that capture the design decisions from a particular perspective
- Viewpoints:
  - Logical
  - Physical
  - Deployment
  - Concurrency
  - Behavioral
- **Consistent** views don't disagree with each other
  - Common inconsistencies:
    - Direct (e.g. 2 vs. 3)
    - Refinement (high-level and low-level disagree)
    - Static vs. dynamic
    - Dynamic vs. dynamic: e.g. state vs. sequence diagram
    - Functional vs. non-functional
- Evaluating modeling approaches
  - Scope and purpose
  - Basic elements
  - Style
  - Static and dynamic aspects
  - Dynamic modeling
  - Non-functional aspects
  - Ambiguity
  - Accuracy
  - Precise
  - Viewpoints
  - Viewpoint consistency
- Modeling approaches:
  - Generic approaches (Natural language, Powerpoint, UML)
  - Early architecture description languages (Darwin, Rapide, Wright)
  - Domain- and style-specific languages (Koala, Weave, AADL)
  - Extensible architecture description languages (Acme, ADML, xADL)
- UML:
  - 13 notations
  - For static and dynamic aspects
  - Advantages:
    - Support for diverse array of viewpoints
    - Common
    - Tool support
  - Disadvantages:
    - Needs customization to reduce ambiguity
    - Hard to determine if views are consistent
    - Hard to capture foreign concepts/views
  - Static structures:
    - Component diagrams
    - Deployment diagrams
    - Class diagrams
  - Dynamic behavior:
    - Sequence diagrams
    - Use case diagrams
    - State machine diagrams
 Architecture description languages
  - Entire programming languages made not for writing programs, but for describing them

## Security & Chrome

- Security words:
  - Confidentiality: Only the right people can access stuff
  - Integrity: Only the right people can change stuff
  - Availability: The right people can do stuff all the time
- Design principles:
  - Least privilege
  - Fail-safe defaults
  - Economy of mechanism
  - Complete mediation
  - Open design
  - Separation of privilege
  - Least common mechanism
  - Psychological acceptability
  - Defense in depth
- Architectural access control models
  - Map from (user, resource) to set of permissions
- Trust:
- Reputation: Past behaviour
- Architecture in Practice: Chrome (read two papers)

## Security, Design introduction.

- Chrome security: Least privilege, separation fo privilege, defense in depth
- Design process: cycle (Measure, Learn, Build)
- Promote:
  - Abstraction: Removal of detail
  - Flexibility: 
  - Modularity
  - Elegance
- STUPID principles:
  - Singleton
  - Tight coupling
  - Untestable
  - Premature optimization
  - Indescriptive naming
  - Duplication
- SOLID principles:
  - Single responsibility: Stuff does one thing
  - Open/closed: Stuff can be extended but not changed
  - Liskov substitution: Subtypes behave exactly as their parents do
  - Interface segregation
  - Dependency inversion
- Lower level principles
  - Encapsulate what varies
  - Program to abstractions, not implementations
  - Composition over inheritance
  - Strive for loose coupling
- Quality attributes
  - Simplicity: Tony Hoare's Obviously no deficiencies vs. no obvious deficiencies
    - DRY
    - KISS
  - Coupling: Content -> Global -> Control -> Data -> Message ->> None
  - Cohesion: Coincidental -> Logical -> Temporal -> Communication -> Sequential ->> Functional
- Cognitive dimensions:
  - Premature commitment
  - Hidden dependencies
  - Secondary notation
  - Viscosity (resistance to change)
- Advantages of design patterns
  - Shared **vocabulary**
  - **Leverage** existing design knowledge
  - More **flexibility**
  - More **reusability**

## #10 - Creational design patterns

- Coupling
  - Content coupling: Directly refer to internal structures of another module
  - Global coupling: Shared globals
  - Control coupling: Change control flow of another class
  - Data coupling: Share data through parameters
  - Message coupling: Message passing
  - None
- Cohesion
  - Coincidental: Random utilities.
  - Logical: Seemingly similar
  - Temporal: Related in time
  - Communication: Same input/output data
  - Sequential: Input piped sequentially
  - Functional: For specifically one task
- Class patterns:
  - Pattern: Factory Method: Creator creates instances.
- Object patterns:
  - Pattern: Abstract Factory: Abstract class with several concrete factories
  - Pattern: Builder: Takes parts and builds an object
  - Pattern: Prototype: Concrete prototypes and cloning
  - Pattern: Singleton: You can only have one of a class, and you can get it from anywhere.

## #11 - Structural design patterns

- Class patterns:
  - Class adapter: Adaptor class multiple-inherits from N adaptees, providing
    access to their methods through a common method. (Some fucked up shit)
- Composition/Aggregation:
  - Composition: The composed cannot exist independently of the composer.
  - Aggregation: The aggregator simply contains some aggregates.
- Object patterns:
  - Object adapter: Adaptor class contains an Adaptee, providing a different
    interface to access it. (Not as screwed up)
  - Bridge pattern:
    - RefinedAbstraction -|> Abstraction (aggregates an Implementor)
    - ConcreteImplementor -|> Implementor (abstract)
  - Composite
    - Tree.
  - Decorator
    - Component (abstract) is an aggregate of Decorators (abstract)
    - Decorator <|- Component
    - ConcreteComponent, ConcreteDecorator implements
  - Facade
    - Provides unified interface to multiple possible implementations
    - Kinda like tableflip/engine
  - Flyweight
    - Share internal structure
    - Kinda like hash consing
  - Proxy
    - Wrapper around expensive-to-instantiate objects
    - Proxy inherit's the RealSubject's interface. Client MAY interact with
      Proxy instead of RealSubject.

## 2017 Oct 17 - #12: Behavioral design patterns

- Midterm goes up to Oct 19
- Behavioral patterns: Oft-used communication techniques.
- Challenge 2: File system with files and directories.
  - Soln: Composite
- Challenge 2b: 2, w/ ls, du, [[ -f X ]]
  - Use... a visitor! LOL!
- Class patterns:
  - Interpreter: For a DOMAIN. SPECIFIC. LANGUAGE.
  - Template Method: Describe the program skeleton.
- Object patterns:
  - Chain of Responsibility:
    - Decorate level over level.
  - Command
  - Iterator
  - Mediator
    - Abstracts away interactions between multiple different objects
    - Unlike Facade, simplifies communication between the classes
      - ( V A L U E - A D D E D )
      - Both Facade and Mediator reduce kyappuringu
  - Memento
    - Remember internal state without messing with it
  - Observer
    - Observers have a notify() method
    - Subject can be registered, deregistered with Observers
  - State
  - Strategy
  - Visitor
    - Aids open/closed principle
    - Client has a ConcreteVisitor -|> Visitor, can visit ConcreteElements
    - Client has a ConcreteElement -|> Element, accepts a Visitor
    - Single dispatch: Traditional dynamic dispatch.
    - Double dispatch: Both element and visitors are dynamically dispatched.
- MVX
  - MVC: MV Controller
  - MVP: MV Presenter
  - MVVM: MV ViewModel

## 2017 Oct 19 - #13: Refactoring, code smells, MVC

- Builder pattern (wikipedia)
  - Breaks down complicated constructors
  - Shitty half-replacement for keyword args
  - Problem with Wikipedia example: Builder instance returns the same car every build
  - Scala one actually works lol
- Refactoring:
  - Restructure code without changing its external behavior
- Code smells:  
  - Large Class, Large Method
  - Deeply Nested Control
  - Duplicate Code (WET)
  - Static State
    - a `public static`... is just a fkn global!
  - No Information Hiding, Bad Encapsulation
  - Many Parameters
  - Casts to Implementation Classes
- MVC
  - Started with Smalltalk-80
  - Java UI frameworks, EJB (Enterprise Java Beans), GWT, .NET
  - Motivation:
    - UI changes more frequently than business logic
    - Same data displayed many ways
    - Designers generally != developers
    - Hard to test UI code
  - Model: Just data
  - View: Presents model
  - Controller: "Glues Model and View together"
  - View is often tightly coupled w/ Controller, because buttons are part of the UI
  - Model UPDATES View IS SEEN BY User USES Controller MANIPULATES Model
- Design exercise: Calculator with +-×÷
- MIDT: Architectural styles, design patterns, UML, reading code
