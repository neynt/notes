# CS 343: Concurrency

Professor: Peter Buhr

## 1. Advanced control flow

Omitted.

## 2. Exceptions

- Static/Dynamic Call/Return
- Static propagation
  - Sequel
- Dynamic propagation
  - Termination
  - Resumption `_Resume`

## 3. Coroutine

- State:
  - Execution location
  - Exeuction state (each coroutine has its own stack)
  - Execution status (active / inactive / terminated)
- A Life With N Stacks
- Semi-coroutine: Asymmetrical.
- Full-coroutine: Symmetrical.
- Linearization: Making loops flat.
- Pull coroutine: Generates things in next().
- Push coroutine: Accepts things in next().
- Leverage the coroutine zen.
- Exception handling: `_Throw`, `_Suspend ... [_At]`, `_Catch`, `_CatchResume UnhandledException`
- For assignment: `_Enable` in `main()`.

## 4. µC++ EHM

Omitted.

## 5. Concurrency

- Things that are things:
  - Thread: Execution path
  - Process: Program component with a thread
  - Task: Reduced process. Lightweight process
- Thread states: new, ready, running, blocked, halted
- CPUs run kernel threads run user threads
- Speedup is typically sublinear or (badly) nonlinear
- Amdahl's law: SC = 1 / ((1 - P) + P/C)
- Concurrency in µC++:
  - Include `<uCobegin.h>`
  - COBEGIN BEGIN END ... BEGIN END COEND
    - Can represent some lattices
  - auto x = START, WAIT(x)
  - COFOR(var, 0, 10) loops for row from 0 to 9
  - `_Task` objects
- Mutual Exclusion Game
  - Rules:
    - 1. Safety: Only one thread in something's critical section.
    - 2. Threads may run at any speed, in any order.
    - 3. Threads may not entering/leaving a critical section cannot prevent
         other threads from entering it.
    - 4. Liveness: No indefinite postponement / livelock.
    - 5. No starvation: Threads that have started must eventually enter CS.
- Software solutions to mutual exclusion
  - 1. Lock. Breaks rule 1.
  - 2. Alternation. Breaks rule 3.
  - 3. Declare Intent. Breaks rule 4.
  - 4. Retract Intent. Breaks rule 4.
  - 5. Prioritized Retract Intent. Breaks rule 5.
  - 6. Dekker's algorithm. Not RW-safe (non-atomic writes)
    - Hesselink: RW-safe version.
    - Unbounded overtaking: Race loser retracts intent
  - 7. Peterson's algorithm. Not RW-safe
    - Bounded overtaking: Race loser does not retract intent
      - Thread exiting critical section does not immediately re-enter.
  - 8. n-thread prioritized entry. Breaks rule 5.
  - 9. n-thread bakery.
  - 10. Tournament. Binary tree of Dekkers or Petersons.
  - 11. Arbiter. Task controls entry.
- Hardware solutions
  - 1. Test/set instruction: Attempts to set value of lock. Returns success if actually changed.
  - 2. Swap instruction: Atomic exchange of values.
  - 3. Fetch and increment: Increments a value and returns the original value.

## 6. Locks.

- Two types: spinning and blocking.
- Spinning:
  - No yield
  - Yield: Yields after a single failed check.
- Blocking: Must cooperate
  - Synchronization
    - Condition
    - Barrier
  - Semaphore
    - Binary
    - Counting
  - Mutex
    - Owner
  - (Many others)
- Mutex lock
  - Type of blocking lock
  - Single acquisition: Acquirer cannot acquire lock again
  - Multiple acquisition: Acquirer can acquire lock multiple times
  - May require only one release, or as many releases as acquires
  - Implementation details:
    - Don't block when holding the lock: Release lock before blocking
    - Race between blocking and unblocking tasks.
    - Magic: yieldNoSchedule( lock );
  - Barging: Acquiring tasks can barge ahead of the released task.
  - Barging avoidance: Hold inUse flag between releasing and unblocking task
  - Barging prevention: Hold lock between releasing and unblocking task
- Synchronization lock
  - To block tasks waiting for synchronization.
  - External locking: External lock protects task list. Very dangerous
  - Internal locking: Lock is part of state.
  - In uC++: uOwnerLock
- Stream locks: sync locks for I/O streams in particular
  - In uC++: osacquire( cout )
- uCondLock
  - in uC++: uCondLock
- Barrier
  - Does not proceed until specified number of tasks block on the barrier
  - In uC++: uBarrier
- Binary semaphore
  - P: acquire (set inUse to true)
  - V: release (set inUse to false)
- Counting semaphore:
  - P: decrement
  - V: increment
  - Has an initial value (the "maximum concurrency")
  - in uC++: uSemaphore
    - has TryP: returns success

- Precedence graph
  - DAG of dependencies
  - To solve with semaphores, assign each code segment a semaphore, V after it's done, P before dependencies, some more V's to ensure it actually works
- Buffering
  - Unbounded buffer: Buffer is of unbounded length.
  - Bounded buffer: Buffer has some max length.
    - Producers have to wait if the buffer is full.
    - Consumers have to wait if the buffer is empty.
- Lock techniques
  - Split binary semaphore: Collection of semaphores where at most one is 1.
  - Baton passing: Using split binary semaphores to "pass a baton" around
- Readers and Writers problem. Read notes
  - Seven Solutions, All My Husbands

- On the assignment, Barrier use is very simple.

# 7. Concurrent errors

- 
