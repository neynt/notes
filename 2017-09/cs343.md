# CS 343: Concurrency

Professor: Peter Buhr

## 1. Advanced control flow

Omitted.

## 2. Exceptions

- Calls can be static or dynamic
- Returns can also be static or dynamic
- Static propagation
  - Sequel
- Dynamic propagation
  - Termination
  - Resumption `_Resume`

## 3. Coroutine

- State:
  - Execution location
  - Exeuction state (each coroutine has its own stack)
  - Execution status (active / inactive / terminated)
- A Life With N Stacks
- Semi-coroutine: Asymmetrical.
- Full-coroutine: Symmetrical.
- Linearization: Making loops flat.
- Pull coroutine: Generates things in next().
- Push coroutine: Accepts things in next().
- Leverage the coroutine zen.
- Exception handling: `_Throw`, `_Suspend ... _At`, `_Catch`, `_CatchResume UnhandledException`
- For assignment: `_Enable` in `main()`.

## 4. µC++ EHM

Omitted.

## 5. Concurrency

- Things that are things:
  - Thread: Execution path
  - Process: Program component with a thread
  - Task: Reduced process. Lightweight process
- Thread states: new, ready, running, blocked, halted
- CPUs run kernel threads run user threads
- Speedup is typically sublinear or (badly) nonlinear
- Amdahl's law: SC = 1 / ((1 - P) + P/C)
- Concurrency in µC++:
  - Include `<uCobegin.h>`
  - COBEGIN BEGIN END ... BEGIN END COEND
    - Can represent some lattices
  - auto x = START, WAIT(x)
  - COFOR(var, 0, 10) loops for row from 0 to 9
  - `_Task` objects
- Mutual Exclusion Game
  - Rules:
    - 1. Safety: Only one thread in something's critical section.
    - 2. Threads may run at any speed, in any order.
    - 3. Threads may not entering/leaving a critical section cannot prevent
         other threads from entering it.
    - 4. Liveness: No indefinite postponement / livelock.
    - 5. No starvation: Threads that have started must eventually enter CS.
- Software solutions to mutual exclusion
  - 1. Lock. Breaks rule 1.
  - 2. Alternation. Breaks rule 3.
  - 3. Declare Intent. Breaks rule 4.
  - 4. Retract Intent. Breaks rule 4.
  - 5. Prioritized Retract Intent. Breaks rule 5.
  - 6. Dekker's algorithm. Not RW-safe (non-atomic writes)
    - Hesselink: RW-safe version.
    - Unbounded overtaking: Race loser retracts intent
  - 7. Peterson's algorithm. Not RW-safe
    - Bounded overtaking: Race loser does not retract intent
      - Thread exiting critical section does not immediately re-enter.
  - 8. n-thread prioritized entry. Breaks rule 5.
  - 9. n-thread bakery.
  - 10. Tournament. Binary tree of Dekkers or Petersons.
  - 11. Arbiter. Task controls entry.
- Hardware solutions
  - 1. Test/set instruction: Attempts to set value of lock. Returns success if actually changed.
  - 2. Swap instruction: Atomic exchange of values.
  - 3. Fetch and increment: Increments a value and returns the original value.

## 6. Locks.

- Two types: spinning and blocking.
- Spinning:
  - No yield
  - Yield: Yields after a single failed check.
- Blocking: Must cooperate
  - Synchronization
    - Condition
    - Barrier
  - Semaphore
    - Binary
    - Counting
  - Mutex
    - Owner
  - (Many others)
- Mutex lock
  - Type of blocking lock
  - Single acquisition: Acquirer cannot acquire lock again
  - Multiple acquisition: Acquirer can acquire lock multiple times
  - May require only one release, or as many releases as acquires
  - Implementation details:
    - Don't block when holding the lock: Release lock before blocking
    - Race between blocking and unblocking tasks.
    - Magic: yieldNoSchedule( lock );
  - Barging: Acquiring tasks can barge ahead of the released task.
  - Barging avoidance: Hold inUse flag between releasing and unblocking task
  - Barging prevention: Hold lock between releasing and unblocking task
- Synchronization lock
  - To block tasks waiting for synchronization.
  - External locking: External lock protects task list. Very dangerous
  - Internal locking: Lock is part of state.
  - In uC++: uOwnerLock
- Stream locks: sync locks for I/O streams in particular
  - In uC++: osacquire( cout )
- uCondLock
  - in uC++: uCondLock
- Barrier
  - Does not proceed until specified number of tasks block on the barrier
  - In uC++: uBarrier
- Binary semaphore
  - P: acquire (set inUse to true)
  - V: release (set inUse to false)
- Counting semaphore:
  - P: decrement
  - V: increment
  - Has an initial value (the "maximum concurrency")
  - in uC++: uSemaphore
    - has TryP: returns success

- Precedence graph
  - DAG of dependencies
  - To solve with semaphores, assign each code segment a semaphore, V after it's done, P before dependencies, some more V's to ensure it actually works
- Buffering
  - Unbounded buffer: Buffer is of unbounded length.
  - Bounded buffer: Buffer has some max length.
    - Producers have to wait if the buffer is full.
    - Consumers have to wait if the buffer is empty.
- Lock techniques
  - Split binary semaphore: Collection of semaphores where at most one is 1.
  - Baton passing: Using split binary semaphores to "pass a baton" around
    - Nobody can move in the entry/exit code unless you have the baton.
    - Once the baton is released, you cannot read or write variables in the entry/exit code.
- Readers and Writers problem. Read notes
  - Seven Solutions, All My Husbands
  - Solution 1:
    - Typical baton-passing solution.
    - HOLD THE FUCK UP, there STARVING WRITERS in the house.
  - Solution 2:
    - Make readers wait if there are any waiting writers.
    - Writers favour writers.
    - Readers starve instead of writers.
  - Solution 3:
    - Alternate readers and writers. (by Dekker)
    - Eliminates starvation.
    - Causes staleness/freshness issues
  - Solution 4:
    - Service readers and writers in temporal FIFO order.
    - Allow concurrent readers.

- On the assignment, Barrier use is very simple.
  - Can confirm.

- Who's talking? Can you shut up? 'Cause I'm talking.
- Oh yeah, just a little bit of documentation and I'm finished.
- I'm in the Bomber! You're writing if statements!
- Use the Zen of the Counting Semaphorek.
- Producer/consumer: The produce and consumer critical sections are DEPENDENT. (TW: Midterm)
- I have flogged this example into thin soup.
- That's horrifying. Panic is the only word.

- Professional party-goer:
  - Around 2 o'clock, you look around; if the party is winding down, gtfo or you'll have to clean up

- Our assignments always start with a performance test because it's really hard to judge performance in concurrency.

## 8. Indirect communication

- Transactional memory looks like a bust
- Can the language help us with concurrency?
- Compilers are great for grinding the low level stuff.
- 8.1: Critical regions
  - Object oriented programming was done by the Norwegians
  - SIMULA 67
    - COROUTINES were there. Boy did they get it right.
  - `VAR v: SHARED INTEGER MutexLock v_lock;`
    - "v is a SHARED INTEGER. It has CONCURRENCY."
  - `REGION v DO // critical section END REGION`.
    - Acquires mutual exclusion on v.
  - In uC++: `_Task` says you're writing a concurrent program.
- 8.2: Conditional critical regions
  - `REGION v DO AWAIT condition ... END REGION`
    - Waits for a condition to be true as well as taking the lock
- 8.3: Monitor
  - Norwegian object-oriented + concurrent love bb.
  - Magically provides serialized modification.
  - `_Mutex` members: Only one thread can be in any of them at once.
  - `_Nomutex`: Explicitly disable mutex
- 8.4: Scheduling
  - `_Accept`: Requires a call to the given method before execution continues
  - `uCondition`: queue of waiting tasks. .wait(), .signal(), .signalBlock()
- 8.8: Java monitor
  - synchronized makes members `_Mutex`

- [Nested monitor problem]:
  - Achieved by: [Acquire monitor X, call monitor Y, wait on condition in Y.]
  - Causes a potential deadlock
  - No known solution

- 8.6: Condition, signal, wait vs. counting semaphore, V, P

- [Spurious wakeup]:
  - Have to put your Java wait() in a loop.
  - A conspiracy. It doesn't exist.

- Cannot build condition variables in Java because it deadlocks at condition.Wait() since monitor's mutual exclusion lock is not released.

## 7. Concurrent errors

- Race condition: Missing synchronization or mutual exclusion
- 7.2.1: Livelock. Poor scheduling in entry protocol. "You go first" indefinitely. Oracle with cardboard test.
- 7.2.2: Starvation. Someone never runs. No long term fairness. Long-term rare, short-term starvation is a problem.
- 7.2.3: Deadlock. Processes waiting for an event that will never occur.
- 7.2.3.1: Synchronization deadlock. Failure in cooperation. Blocked task never unblocked.
- 7.2.3.2: Mutual exclusion deadlock. Indefinite failure to acquire a resource.
- Five deadlock conditions:
  - 1. Mutual exclusion: A CONCRETE shared resource requires it.
  - 2. Hold and wait: A process holds the resource while waiting for access to a resource held by another resource.
  - 3. No preemption: Resource never forcibly released.
  - 4. Circular wait.
  - 5. The previous four must occur SIMULTANEOUSLY.
- 7.3: Deadlock prevention.
- 7.3.1: Synchronization prevention. Just have no synchronization / communication.
- 7.3.2: Mutual exclusion prevention.
  - No mutual exclusion (usually not possible)
  - No hold and wait (do not give resource until all resources can be given)
    - Starvation possible
  - Allow preemption (cannot apply statically)
  - No circular wait: Use ordered resources
  - Prevent simultaneous occurrence: Show that the previous 4 cannot occur simultaneously.
- 7.4: Deadlock avoidance
  - Monitor locks and resources and detect potential deadlocks.
  - 7.4.1: Banker's algorithm
    - We know this!
  - 7.4.2: Allocation graphs.
    - Create bipartite graph of resources and tasks.
    - No cycles means no deadlocks
    - Cycle means potential deadlock; may be fixable if resources have multiple instances
- 7.5: Detection and recovery
  - Kill deadlocked tasks
- 7.6: Which method to choose?
  - Most people don't do anything (Gates, Jobs)
  - Only ordered resource policy has been found to be practical IRL

## 9. Direct communication

- One task can CALL another task.
- A Task is a Cormonitor with its own thread.

- Oracle with cardboard test: if you can put cardboard in front of someone's eyes, and that
  fixes the problem, then it's a livelock. Otherwise, it's a deadlock.
  So some students say weeping angels is deadlock because of FEELINGS, not REALINGS.

- 9.3: Increasing concurrency
  - Client: caller. Server: callee.

- 9.3.1: Server-side communication.
- 9.3.1.1: Internal buffer.
- 9.3.1.2: Administrator.
  - The administrator never calls anyone.
  - async calling: "a thing people invent for their language that interface with an Administrator"
- 9.3.2: Client-side communication.
- 9.3.2.1: Returning values is hard.
- 9.3.2.2: Tickets.
  - Are hard. Error prone. Forgery possible.
- 9.3.2.3: Call-back routine.
- 9.3.2.4: Futures.
  - Future is returned immediately by call to server.
  - When the client tries to use the future, it blocks until the result is available.
  - `Future_ESM`: Wicked complicated, sophisticated. Allocated and deallocated by client.
    - not on exam !!
  - `Future_ISM`: Simpler, automatically allocates and frees storage.
  - `Future_ISM` can also be a future pointer.
    - e.g. can point variably to watcard / giftcard
  - Futures can be selected: `_Select ( f1 || f2 && f3 )`
  - Can also: `_Select( f1 ) or (_Select( f2 ) and _Select( f3 ))`
    - This blocks until either f1 or (f2 and f3) is done
  - Assignment is very simple. Complicated futures means you're way off into the pasture.
  - Use the simplest select statement on the planet.
