# SE 350: Operating Systems

Professor: Sebastian Fischmeister.

## Introduction

An operating system makes it easy to use your hardware by providing a collection of abstractions. Its responsibilities include: 
- Managing resources like CPU and RAM
- Providing services to system users
- Consuming resources itself

### Background

Originally, hardware was expensive (compared to people). Now it is cheap, so we want to make it easier to use. A computer has lots of hairy parts, including:

- CPUs
- Memory
- I/O modules (like disk, network)
- Timers
- Interrupt controllers
- System buses

**User-visible registers** are accessible by programs in user space. These include **data registers** and **address registers**. 

**Invisible registers** are not easily accessible. For example, **control** and **status** registers are invisible, and **conditional codes**/**flags** are used only implicitly.

**Interrupts** are events that cause the CPU to jump directly to an interrupt handler before restoring the current context. Types of interrupts include:

- program: for bad behavior in the program
- timer: generated to run things at a scheduled interval
- I/O: signals completion or error of an I/O controller, e.g. in direct memory access
- hardware failure

### History

This is the progression of how the operating system was developed.

- In the very old days, people reserved computer time using pen and paper. This sucked.
- **Batch systems** were introduced, where you could use a job control language to run one job after another. This was a bit better.
- The **monitor** was introduced to help batch systems run better, and brought with it memory protection, timers, privileged instructions, and processor modes like user mode and kernel mode.
- **Time-sharing systems** were introduced so that jobs could run while other jobs wait for I/O. This is called **multiprogramming** and it makes things a lot better.
- Operating systems developed further with processes, memory maagement, security, and scheduling.

### Windows

The **executive** contains core OS services. The **kernel** controls execution of processors. The **HAL** (hardware abstraction layer) abstracts away hardware and does SMP. **Device drivers** are dynamic libraries that interface with specific hardware and things like filesystems. **Windowing and graphics system** is also a separate thing.

## Operating systems

The kernel is the core of the operating system. A **monolithic** kernel has a gigantic "do everything" program. A **microkernel** only provides the minimum necessary for everything else to be taken over in userspace.

## Processes

A process consists of a program's code, as well as:
- A process ID
- Tunning state
- Priority relative to other processes
- Resource assignments
- Owner
- I/O status
- Accounting stats

The operating system stores processes in a data structure called a **process control block** (PCB).

The dispatcher runs the process.

Processes can be terminated for various reasons.

Note that if you use a single dispatch queue, you may dispatch a process that is still waiting. So we typically use multiple queues: a "ready" queue and a "busy" queue.

Because of this, processes typically exist in a five-state machine.
- New
  - on admit, Ready
- Ready
  - on dispatch, Running
- Running
  - on event wait, Blocked
  - on release, Exit
- Blocked
  - on event occurrence, Ready
- Exit

Note that a New state is necessary so that we can ensure that there are enough resources to put the process on the PCB, and an Exit state is necessary for cleanup.

## Other

- PID 0 inherits orphans
- **Multithreading** allows a single process to run multiple units of execution.
- **Virtual memory** allows for the hard disk to be used like primary storage.
- Kernels these days must handle **symmetric multiprocessing** -- multiple homogeneous execution units.
- **Asymmetric multiprocessing** -- heterogeneous execution units.

## Facts

### Ch 1

- Memory hierarchy
  - Hit ratio: Percent of memory accesses that hit a cache
  - Registers
    - Memory address register (MAR):
      - Specifies address in memory for next I/O operation
    - Memory buffer register (MBR):
      - Contains data that needs to be written to, or that was read from, memory
    - I/O address register (I/OAR), I/OBR:
      - Specifies the I/O device and contains data for I/O
  - Cache memory
    - Slot: A "line" of words
  - Main memory
  - Disk
- Central processing unit: A unit of execution
  - Multicore
    - Multiple processors on a single die (piece of silicon)
  - Multiprocessor
  - Uniprocessor:
    -
  - Symmetric multiprocessor:
    - Processors are similar
    - Memory and I/O is shared
    - Processors interact
- Data register
- Input/output
- Instruction
  - Instruction cycle
  - Instruction register
- Interrupt
- I/O
  - Programmed I/O:
    - Polling I/O module
    - Entire system is degraded.
  - Interrupt-driven I/O:
    - I/O module interrupts processor when it's done
    - Limits transfer rate due to processor speed and servicing.
  - Direct memory access (DMA):
    - DMA module (possibly separate from I/O module) handles entire I/O from memory directly.
    - Most excellent
- Locality
  - Spatial locality
  - Temporal locality
  - Locality of reference
    - Memory references tend to cluster due to loops and stuff
- Program counter
- Reentrant procedure
- Register
- Secondary memory
- Stack
- System bus

### Ch 2

- Batch processing
- Interrupt
- Job
  - Job control language
- MTTF: Mean time to failure.
- MTTR: Mean time to repair.
- Monitor
- Resident monitor
- Uniprogramming
- Multiprogramming
  - Multiprogrammed batch system
- Multitasking
- Multithreading
- Operating system
  - Kernel: (aka Nucleus)
    - Microkernel
    - Monolithic kernel
  - Kernel mode: 
  - User mode:
- Physical address
- Real address
- Virtual address
- Privileged instruction
- Process
  - Process state
  - Execution context
- Round-robin
- Scheduling
- Serial processing
- Symmetric multiprocessing
- Task
- Thread
- Time sharing
- Timesharing system
- Time slicing
- Uniprogramming
- User mode
- Virtual machine
- Virtual memory

- Operating system goals
  - Convenience -- make computer easier to use
  - Efficiency -- better utilize computer
  - Ability to evolve -- be a good abstraction
- History
  - Serial processing: Scheduling and setup
  - Batch systems
    - Monitor. Programs branch back to it when finishing, and it decides which program to run next.
      - Resident monitor: part that controls sequence of events.
      - Also has utils and functions
    - Job control language: instructions for the monitor
    - Hardware features:
      - Memory protection
      - Timer
      - Privileged instructions
        - One consequence: Monitor retains control of I/O devices
        - Introduces user mode and kernel mode
      - Interrupts
  - Multiprogrammed batch system
    - Multiprogramming / multitasking:
      - Multiple programs at once
      - Switch between them when waiting on I/O
    - Uniprogramming is not multiprogramming
  - Time sharing systems
    - For interactive things
    - Interleave user time in short bursts
    - Time slicing: Using clock interrupts to reassign CPU control
- Process: Program, execution context (process state), and resources
  - Four main causes of errors:
    - Improper synchronization (of I/O)
    - Failed mutual exclusion (of shared resources)
    - Nondeterminate program operation: programs screwing with other programs' memory space and affecting their operation
    - Deadlocks: programs waiting on each other in a loop
- Memory management:
  - Roles of the OS:
    - Process isolation
    - Automatic allocation
    - Support modular programming
    - Protection and access control (for shared memory)
    - Long-term storage
  - Virtual address: Page number and offset
  - Real address / Physical address: Actual address
  
