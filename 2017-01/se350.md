# SE 350: Operating Systems

Professor: Sebastian Fischmeister.

I used to have nicely written notes, but since the course content is kind of just a collection of facts, I'm just summarizing testable material from the textbook.

Lectures are good for seeing really cool demos. Not good for learning the things that will be on quizzes.

### Cool Demos Man

### Ch 3

- 2017-01-24: Multithreading with pthread, passing pointer to local stack, race condition.
- 2017-01-24: pth_burner.c
  - User-level threads with pth.
  - Only one thread works, is never blocked so never hands off control.
- 2017-01-24: pthreads_burner.c: Kernel-level threads. All threads run at a time. I/O works.

### Ch 1

- Four parts of a computer
  - CPU
  - Main memory
  - I/O modules
  - System bus
- Four general types of instruction
  - Processor-memory
  - Processor-I/O
  - Data processing (math)
  - Control
- Four types of interrupt
  - Exceptions
  - Timer
  - I/O
  - Hardware failure
- Registers
  - Memory address register (MAR):
    - Specifies address in memory for next I/O operation
  - Memory buffer register (MBR):
    - Contains data that needs to be written to, or that was read from, memory
  - I/O address register (I/OAR), I/OBR:
    - Specifies the I/O device and contains data for I/O
- Reentrant procedure: Single copy of code can be shared by many users
- Interrupt processing
  - Processor saves PSW, PC onto a control stack
  - Interrupt handler saves all other registers onto the control stack
  - Interrupt handler restores saved register values
  - Processor restores PSW, PC
- Ways to handle multiple interrupts
  - Disable interrupt in interrupt handlers
  - Prioritize interrupts and push lower-priority handler contexts onto a stack
- Memory hierarchy
  - Register, cache, primary, secondary
  - Locality of reference: Memory references cluster due to loops
    - Spatial locality: Sequentially accessed memory locations tend to be clustered (or themselves sequential)
    - Temporal locality: Recently used memory locations tend to be used again
- Cache memory
  - Cache size
    - Main memory has 2^n words
    - Main memory broken up into 2^n / K blocks of size K
    - Cache has C slots of K words each, C << M
  - Block size
  - Mapping function
  - Replacement algorithm (LRU > FIFO > random)
  - Write policy
  - Hit ratio: Percent of memory accesses that hit the cache
- I/O
  - Programmed I/O: processor polls I/O module
  - Interrupt-driven I/O: I/O module interrupts when ready
  - Direct memory access: DMA module (not necessarily same as I/O module) interacts with memory directly
- Multiprocessor
  - SMP: Similar processors, share memory and I/O

### Ch 2

- Operating system goals (CEA)
  - Convenience -- make computer easier to use
  - Efficiency -- better utilize computer
  - Ability to evolve -- be a good abstraction
- History
  - Serial processing: Scheduling and setup
  - Batch systems
    - Monitor. Programs branch back to it when finishing, and it decides which program to run next.
      - Resident monitor: part that controls sequence of events.
      - Also has utils and functions
    - Job control language: instructions for the monitor
    - Hardware features:
      - Memory protection
      - Timer
      - Privileged instructions
        - One consequence: Monitor retains control of I/O devices
        - Introduces user mode and kernel mode
      - Interrupts
  - Multiprogrammed batch system
    - Multiprogramming / multitasking:
      - Multiple programs at once
      - Switch between them when waiting on I/O
    - Uniprogramming is not multiprogramming
  - Time sharing systems
    - For interactive things
    - Interleave user time in short bursts
    - Time slicing: Using clock interrupts to reassign CPU control
- Process: Program, execution context (process state), and resources
  - Four main causes of errors (FIND):
    - Failed mutual exclusion (of shared resources)
    - Improper synchronization (of I/O)
    - Nondeterminate program operation: programs screwing with other programs' memory space and affecting their operation
    - Deadlocks: programs waiting on each other in a loop
- Memory management:
  - Roles of the OS (PASPL):
    - Process isolation
    - Automatic allocation
    - Support modular programming
    - Protection and access control (for shared memory)
    - Long-term storage
  - Virtual address: Page number and offset
  - Real address / Physical address: Actual address
- Security and protection (ACDA)
  - Availability
  - Confidentiality
  - Data integrity
  - Authenticity
- Resource management factors: (FED)
  - Fairness (Proccesses of the same class have fair and equal access to resources)
  - Efficiency: Maximum throughput, minimize response time
  - Differential responsiveness (More important processes have priority)
- Round-robin: Each process in a queue takes turns
- Modern OS developments
  - Microkernel: Kernel only has essential functions, unlike monolithic kernel
  - Multithreading
  - Symmetric multiprocessing
    - Advantages over uniprocessor (PAIS):
      - Performance -- parallelizable work done faster
      - Availability -- failure of a single processor does not kill everything
      - Incremental growth -- add processors to make things faster
      - Scaling -- sell wider variety of computers by adding more processors
  - Distributed operating systems: Huh-doop like. Lol no.
  - Object-oriented design: Used in development
- Faults
  - Types
    - Permanent (e.g. failed disk)
    - Temporary
      - Transient (e.g. RAM bit flip)
      - Intermittent (e.g. loose connection)
  - Fault tolerance
    - Reliability R(t) is probability system is still up after t time.
    - MTTF: Mean time to failure. Average time system stays up. = Integral 0 to infinity of R(t)
    - MTTR: Mean time to repair. Average time system stays down.
    - Availability: Fraction of time the system is up. = MTTF / (MTTF + MTTR)
  - Types of redundancy (STI)
    - Spatial / physical (e.g. backup server)
    - Temporal (e.g. retransmission)
    - Information (e.g. RAID)
  - Fault tolerance in OSes (PCVC)
    - Process isolation
    - Concurrency controls
    - Virtual machines
    - Checkpoints and rollbacks
- Multiprocessor / Multicore
  - Considerations (SSSRM):
    - Simultaneous concurrent processes / threads
    - Scheduling
    - Synchronization
    - Reliability / fault tolerance
    - Memory management
  - Grand Central Dispatch: Thread pool of lambdas
- Windows
  - Windows NT:
    - Executive: Memory management, processes, threads, security, I/O, IPC. Threaded.
    - Kernel: Processs execution, scheduling, switching, exceptions and interrupts, multiprocessor. Not threaded.
    - HAL: Maps generic hardware commands to platform-specific ones
    - Device drivers: Extend Executive.
- Unix
- Modern Unix
- Linux
  - Loadable modules
  - Signals (SIGKILL, SIGTERM, SIGINT, SIGSEGV, SIGTRAP)
  - Syscalls
- Android
  - Activities
  - Alarms

### Ch 3

- Task

- Process control block: keeps track of a process.
  - Identifier
  - State
  - Priority
  - PC
  - Memory pointers
  - Execution context
  - I/O status
  - Accounting
- Scheduler picks which process to run next
- Dispatcher switches the processor from one process to another
- Process states
  - Two-state model: (Enter) -> Running -> (Dispatch) / <- (Pause) Not running (Exit) ->
  - Five-state model:
    - New (admit -> Ready)
      - Still in disk. Not yet committed to running in memory.
    - Ready (dispatch -> Running)
    - Running (time-out -> Ready, event wait -> Blocked, release -> Exit)
    - Blocked (event occurs -> Ready)
    - Exit
  - Seven-state model:
    - Split Ready and Blocked out to produce Ready / Suspend and Blocked / Suspend
    - Allows for better swapping processes back in
  - When one process spawns another, the spawned process is a child and the spawner is a parent
- Trace: Sequence of instructions
- Swapping: Use disk to store a process
- Process image: The collection of all data associated with a process, including its PCB, stack, program code, and data
- Modes:
  - User mode: Least privileged.
  - System mode / Control mode / Kernel mode: Most privileged.
  - Determined by bit in PSW.
- Reasons for process creation:
  - New batch job
  - Interactive log-on
  - Created by OS to service a user
  - Spawned
- Process creation process:
  - Assign PID.
  - Allocate space for stack, heap, PCB
  - Initialize PCB
  - Set up linkages
  - Set up other data structures
- When to switch processes:
  - Clock interrupt
  - I/O interrupt
  - Memory fault (addr outside of virtual memory range)
- Ways to interrupt process execution:
  - Interrupt
  - Trap: Using an error or exception to stop process at a certain point.
  - Supervisor call: system call
- Interrupt handling:
  - PC = interrupt handler (hardware)
  - Switch to kernel mode (hardware)
- Execution of the OS
  - Nonprocess kernel
  - Execute within user processes

### Ch 4

- Power Words
  - Jacketing kernel-level thread
  - Lightweight process
  - Message
  - Multithreading
  - Port
  - Process
  - Task
  - Thread
  - User-level thread

- Multithreading
  - Processes have multiple threads
  - Threads run independently
  - Threads share memory space
  - Advantages of threads:
    - Creating is faster
    - Terminating is faster
    - Switching is faster
    - Communication is faster: no IPC or kernel involved; just share RAM!
  - Uses of threads:
    - Foreground / Background work
    - Asynchronous processing
    - Making programs faster
    - Making programs more modular
  - Thread states:
    - Spawn:  TODO

### Ch 5

- Power words
  - binary semaphore
  - blocking
  - busy waiting
  - concurrency
  - concurrent processes
  - coroutine
  - counting semaphore
  - critical resource
  - general semaphore
  - message passing
  - monitor
  - mutex (mutual exclusion lock)
  - nonblocking
  - semaphore
  - spin waiting
  - strong semaphore
  - weak semaphore

- Key concurrency words
  - Atomic: a sequence of instructions that must appear to happen all at once
  - Critical section: section of code that requires access to shared resources
  - Deadlock: multiple processes blocked because each waits for the other
  - Livelock: multiple processes mutually do nothing in response to each other
  - Mutual exclusion: only one process can access a shared resource at a time
  - Race condition: result depends on order of thread execution
  - Starvation: process never scheduled
[...]
- Process interaction
  - Unaware of each other.
    - Not intended to work together..
    - Competition.
  - Indirectly aware of each other.
    - Know each other's PIDs.
    - Cooperation by sharing.
  - Directly aware of each other.
    - Communicate by PID and work jointly on an activity.
    - Cooperation by communication.
- Mutual exclusion
  - Software approach: Dekker's algorithm in some library or OS/language support.
  - Hardware support
    - Disable interrupts to make a critical section atomic
      - Does not work if there is multiprocessing, multicore or multi-processor.
    - Hardware-level instructions to achieve mutual exclusion:
      - compare&swap: replace a value only if it is equal to some test value
      - exchange: swap register and memory location atomically
- Concurrency control mechanisms
  - Semaphore (counting / general)
    - Shared variable which can be atomically initialized, decremented, or incremented
    - Initialize: inits with non-negative value
    - semWait: decrements. blocks the caller if value becomes negative
      - No way to determine if it will block!
    - semSignal: increments. unblocks a process if value is still at most 0
      - No way to determine if it will wake up another process!
    - Binary semaphore: semaphore with values 0 or 1
    - Mutex: binary semaphore where the same process needs to take and release lock.
    - Strong semaphore: FIFO blocked queue. free from starvation.
    - Weak semaphore: no order to pop from blocked queue. may starve.
    - Producer / consumer problem
      - Semaphores are hard. Get used to them.
      - Use local variables to prevent preemption from fucking shit up
  - Monitor
    - 
